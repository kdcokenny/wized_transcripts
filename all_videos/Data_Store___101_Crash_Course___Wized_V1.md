Let's talk about data stores, why we need them, and how they work. Data stores, as we remember, are one of the parts almost every web application has. We use a data store to temporarily store the state of a web application in a central and accessible way. Also, we want one single source of data. Another nice property of our data store is that its data is reactive. That means that everywhere where you use values from the data store, every element connection, every formula gets automatically updated whenever a value in your data store changes. Okay, as we now know why we use them and how they work, let's talk about what Wizard stores inside them. Of course, as we can see, Wizard automatically stores the real return values of our requests in the data store. Together with the return values, Wizard also automatically stores the request state in our data store. The request state of every request consists of three variables. IsRequesting is true when the request is currently being performed. A great use for this variable is to use it for targeting the visibility of loading spinners on your page. When we have our hasRequested value, then we have our hasRequested value, which is true if our request has been executed at least once since the original page load. And finally, we have the status code of our request. The status code is contained in our request response and indicates whether everything worked flawlessly or if our request has some issues server-side. A status code of 200 thereby means that everything worked fine. 500 would be a server error, and a 301 error would mean that the request we are trying to request has been moved. 404 would mean that the resource is not present. You might have already gotten that one when surfing the web. And so on. There are many more statuses. If you're ever unsure what a status means, google it. Even we developers are doing that all the time. Also, one thing to notice that some request types, like update, create, or delete requests, often don't return any data. So you only have the status code to determine if the request was actually correctly executed. Okay, let's see what other value types we have in our datastore. We have URL parameters. URL parameters can be added as variables via the button in the top bar and will be displayed here if they are set. URL parameters get passed to a page in the link and therefore, for example, are useful when you want to pass the ID of a specific element that you want to load and display on the page. Let's say the ID of a blog post or a product. Additionally, we have the values of all input fields on the page in our datastore. The values will automatically get updated if a user is filling out or changing the value of a field. Then we have a custom variable section, where you can define custom variables that you can then set via onClick or onChange, connections with elements. And lastly, you also have the possibility to set cookies. Think of cookies as variables that you can also access on other pages of your site and which you can define for how long they should be saved in the user's browser. Similar to variables, you can also set cookies via onClick and onChange element connections. In simpler terms, you can trigger the set and update of variables and cookies by user interactions with the site. And that's basically it as a general information to the datastore. As a last note maybe, there are some special things to values of the type array. You can recognize arrays by their light blue color and the small setting symbol next to them. Arrays are a list-like collection of elements. In order to maintain simplicity, Wizard only displays the first value of this list. This value is then called item, or in case a value is of the type object, Wizard would display the properties of the object. What you normally want to do with loaded arrays is to render a list and somewhere use the properties of your array as content. You can learn more about that in our video to the RenderList element setting. Also, by clicking on the settings icon on an array, you can sort or filter arrays. Learn more about that in our next video.